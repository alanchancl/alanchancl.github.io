<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://alanchancl.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alanchancl.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-06-12T06:39:40+00:00</updated><id>https://alanchancl.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">自动驾驶关于对抗攻击的鲁棒性研究</title><link href="https://alanchancl.github.io/blog/2023/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E4%B8%AD%E7%89%A9%E7%90%86%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E7%9A%84%E9%B2%81%E6%A3%92%E6%80%A7%E7%A0%94%E7%A9%B6/" rel="alternate" type="text/html" title="自动驾驶关于对抗攻击的鲁棒性研究"/><published>2023-05-31T11:30:17+00:00</published><updated>2023-05-31T11:30:17+00:00</updated><id>https://alanchancl.github.io/blog/2023/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E4%B8%AD%E7%89%A9%E7%90%86%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E7%9A%84%E9%B2%81%E6%A3%92%E6%80%A7%E7%A0%94%E7%A9%B6</id><content type="html" xml:base="https://alanchancl.github.io/blog/2023/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E4%B8%AD%E7%89%A9%E7%90%86%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E7%9A%84%E9%B2%81%E6%A3%92%E6%80%A7%E7%A0%94%E7%A9%B6/"><![CDATA[<blockquote> <ul> <li>论文名称：<a href="https://arxiv.org/pdf/2007.10115.pdf">Towards Robust Sensing for Autonomous Vehicles: An adversarial perspective</a></li> <li>作者单位：Apostolos Modas / 伦敦玛丽女王大学</li> <li>收录时间：2020 / IEEE Signal Processing Magazine</li> <li>文章亮点：总结了自动驾驶中物理对抗攻击的种类，并具体介绍了针对不同传感器的对抗攻击方法、对抗防御方法。</li> </ul> </blockquote> <h2 id="自动驾驶物理对抗攻击种类">自动驾驶物理对抗攻击——种类</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202305311120665-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202305311120665-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202305311120665-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202305311120665.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="自动驾驶中的对抗样本" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">自动驾驶中的对抗样本</div> <p>作者认为自动驾驶中的对抗样本可以分为两类：The <strong>physical</strong> and <strong>on-signal</strong> adversarial attacks</p> <ul> <li><strong>physical</strong> adversarial attacks：物理对抗攻击，通过更改环境导致系统输出错误结果。例如更改光照亮度、修改交通信号牌等</li> <li><strong>on-signal</strong> adversarial attacks：信号对抗攻击，通过更改传感器获取的信号导致系统输出错误结果。</li> </ul> <p>本文将关注于<strong>物理对抗攻击</strong>。物理对抗攻击也可以分为三类：设备、物体和贴纸三种。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202306041125321-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202306041125321-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202306041125321-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202306041125321.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="物理对抗攻击种类" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">物理对抗攻击种类</div> <ul> <li>设备：用激光发射器瞄准直接干扰传感器。</li> <li>物体：外形伪造成可以被分类器识别为正常物体的障碍物。</li> <li>贴纸：直接贴在交通信号牌中误导分类器</li> </ul> <h2 id="自动驾驶物理对抗攻击设备篇">自动驾驶物理对抗攻击——设备篇</h2> <p>本节中讨论使用设备攻击超声波传感器、雷达、GPS、激光雷达和相机的物理对抗方法。</p> <h3 id="1超声波和雷达传感器">1、超声波和雷达传感器</h3> <p>堵塞攻击（jamming attacks）和欺骗攻击（spoofing attacks）可以操纵毫米波雷达和超声波传感器，用于在自动停车或倒车任务中隐藏或添加物体。这些攻击会扰乱传感器的读数，可能导致碰撞事故。这些攻击方法适用于低速移动的车辆，并采用多种技术干扰传感器信号。</p> <ul> <li>堵塞攻击：持续发射接近传感器共振频率的超声波，降低信号的信噪比，阻止物体的检测，并在自动停车过程中可能导致碰撞。</li> <li>欺骗攻击：针对雷达传感器，欺骗攻击可以隐藏物体（假阴性）或添加伪物体（假阳性）。隐藏物体：攻击者可以生成接近传感器中心频率的干扰波形，从而阻止检测附近的车辆。添加假物：对抗信号模仿了汽车雷达的信号，但由于估计距离的周期性变化，会导致对伪物体的误认。</li> </ul> <h3 id="2gps传感器">2、GPS传感器</h3> <p>对GPS传感器的攻击通常旨在用对抗性发射器伪造GNSS传输信号，发射与卫星发送的信号完全相同的信号，从而导致GNSS接收器（即GPS）计算的位置不正确。因为攻击者必须了解GPS接收器和发射器的内部信息，属于白盒攻击。GPS传感器的攻击主要包括欺骗攻击（spoofing attacks）和重放攻击（replay attacks）。</p> <ul> <li>欺骗攻击：攻击者首先必须发射足够强大的干扰GNSS信号，使接收器失去对卫星的锁定。然后，攻击者可以伪造并发射与合法GNSS信号相同频率且功率更高的伪造GNSS信号到接收器的天线。如果被攻击接收器对伪造信号的锁定持续存在，那么位置估计就受到攻击者的影响。攻击者可以欺骗不同数量的GPS接收器到任意位置，同时保持它们之间的时间同步。</li> <li>重放攻击：攻击者可以以任意额外延迟重放记录的信号，接收器将在一些特定的信号传播延迟之后开始接收重放的导航消息。而这个延迟可以用于控制接收器对位置、速度、时间（PVT）计算的偏移。随机重放攻击可以在模拟中创建数百公里的位置偏移。</li> </ul> <h3 id="3激光雷达">3、激光雷达</h3> <p>针对激光雷达的攻击场景可以分为三类：</p> <ul> <li>front/rear/side：前、后和侧面攻击，指得是靠近自动驾驶车辆的对抗性车辆。</li> <li>roadside：路边攻击，在路边安装的恶意设备。</li> <li>mechanic：机械攻击，在放置自动驾驶车辆上恶意设备。</li> </ul> <p>根据激光雷达的攻击方法可以分为三类：</p> <ul> <li>中继攻击（relay attacks）：在中继攻击中，来自目标车辆的原始信号被从另一个位置中继，以创建虚假回波，并使真实物体的位置看起来更近或更远。</li> <li>欺骗攻击（spoofing attacks）：欺骗攻击创建不存在的物体：原始信号被用作触发器，主动欺骗激光雷达传感器，以中继或重放物体并控制其位置。</li> <li>饱和攻击（saturation attack）：通过用与传感器相同波长的光照射激光雷达来隐藏物体。弱光源会产生随机位置的伪点，而直接照射激光雷达的强光源会完全使传感器或其一部分视野失明。</li> </ul> <h3 id="4相机">4、相机</h3> <p>有两种攻击方法：</p> <ul> <li>camera blinding：致盲攻击会对相机传感器照射光线，从而隐藏其视野范围内的任何物体。当相机无法降低自动曝光或增益时，获取的图像就会过曝，发生全盲或部分盲。致盲攻击的有效性取决于环境光、用于致盲的光源（即波长）和敌对光源与相机之间的距离。</li> <li>auto control confusion：自动控制混淆攻击，攻击的目标是影响相机的自动曝光控制，攻击者向相机发射光束，在新环境条件稳定下来之前（通常在1至6秒之间），自动驾驶无法检测到物体。攻击者不断开关光源以混淆自动控制，因此，与相机可以更渐进地适应新条件的情况（例如驶出隧道时）不同，该攻击是持续进行的。</li> </ul> <h2 id="自动驾驶物理对抗攻击物体贴纸篇">自动驾驶物理对抗攻击——物体、贴纸篇</h2> <h3 id="1激光雷达的对抗物体">1、激光雷达的对抗物体：</h3> <p>通过对抗方法可以生成物理3D对抗对象，以误导基于DNN的LIDAR检测系统。为了合成对抗性对象，首先模拟了可微分的激光雷达渲染器；然后，使用可微的代理函数形成特征聚合；最后，通过设计不同的损失函数来确保生成的对抗性对象的平滑性。</p> <h3 id="2相机的对抗物体">2、相机的对抗物体：</h3> <p>Expectation OverTransformation（EoT）算法可以用于构建三维物理对抗样本，生成的三维物体即使在改变视角、平移和旋转物体、光照条件、相机噪声和其他物理世界因素时仍然具有对抗性。</p> <h3 id="3相机的对抗贴纸">3、相机的对抗贴纸：</h3> <p>也可以称为对抗补丁，以攻击图像分类或者目标检测任务的相机。</p> <h2 id="自动驾驶物理对抗攻击防御方法">自动驾驶物理对抗攻击——防御方法</h2> <h3 id="1超声波和雷达传感器-1">1、超声波和雷达传感器</h3> <p>为了防止攻击和拒绝伪造的回声，通过定制Ping信号和相关性比较来进行物理信号验证。同时，使用超声波传感器和单发射器、多接收器的传感器结构可以实现弹性障碍物检测和攻击者定位。这些方法也可以适用于雷达传感器。</p> <h3 id="2gps">2、GPS</h3> <p>对于给定的参数，接收器首先在正常模式下收集数据（训练数据）。然后，基于正常模式数据，接收器预测参数的未来值，并将预测值与从GNSS获得的值进行比较。如果与预测值的差异超过选定的阈值，接收器将判断自身受到攻击，并丢弃所有位置-速度-时间（PVT）解决方案。 还有基于数据比特流变化的攻击检测和基于拍频相位测量的实时欺骗检测。这些机制通过对GNSS数据的分析和处理，以及与预期的模型进行比较，来检测是否存在欺骗攻击，并采取相应的反制措施。</p> <h3 id="3激光雷达-1">3、激光雷达</h3> <p>对于硬件层面，建议使用多个不同波长的LiDAR传感器共同提供扫描信息，并通过跳过发射脉冲或缩短脉冲周期来增加系统的安全性。对于软件层面，提出了在自动驾驶系统、传感器和机器学习模型层面上的防御方法。在自动驾驶层面上，建议过滤地面反射或避免将点云转换为2D矩阵以减少信息丢失。在传感器层面上，建议通过在LiDAR脉冲中引入随机性来增加攻击的难度。在机器学习模型层面上，建议进行对抗性训练以提高系统对抗攻击的能力。</p> <h3 id="4相机-1">4、相机</h3> <p>为了增强深度神经网络对抗性攻击的鲁棒性，对抗性训练是一种有效的方法。然而，它对模型的干净准确性会有一定的负面影响。为了平衡鲁棒性和准确性之间的矛盾，可以在训练损失中添加正则化项来保持决策边界的平滑性。此外，通过一次同时的反向传播来更新模型参数和图像扰动的快速对抗性训练过程可以提高训练效率。对于目标检测任务，通过使用任务导向的对抗性示例，结合不同任务损失之间的相互作用，可以提高对抗性分类准确性和对抗性目标检测准确性。</p> <h2 id="自动驾驶对抗攻击四大研究方向">自动驾驶对抗攻击——四大研究方向</h2> <h3 id="1评估方法研究">1、评估方法研究</h3> <p>现有的评估方法通常仅限于特定传感器或机器学习模型，并且使用相似的数据集和架构进行评估。这导致评估的结果有限，因为在一个数据集和架构上有效的攻击可能无法适用于不同配置的模型。为了更全面地评估对抗性攻击的可转移性，需要增加数据集和架构的多样性。此外，目前的评估方法通常在白盒或灰盒设置下进行，这与真实情况不符，因为攻击者可能对底层传感系统或机器学习模型的了解是有限的。为了更好地评估对对抗性扰动的鲁棒性，需要设计在黑盒设置下对物理变换具有不变性的攻击方法。测试各种情况下自动驾驶的鲁棒性。</p> <h3 id="2融合攻击研究">2、融合攻击研究</h3> <p>尽管对单个传感系统的对抗性漏洞进行了深入研究，但对融合信号的研究还相对较少。在对抗性环境中，确定导致错误推断的传感器模态可以为我们提供有关非对抗性传感器如何支持系统并帮助其保持鲁棒性的新见解。通过信号融合实现对抗性鲁棒性可以为我们提供更全面的理解。</p> <h3 id="3对抗训练研究">3、对抗训练研究</h3> <p>对抗性训练主要用于图像分类和目标检测，针对在信号上的对抗性示例。它是一个通用的框架，可用于处理各种类型的对抗性扰动，包括基于补丁的扰动和物理扰动。对抗性训练的原则适用于任何感知模态，只要底层系统是机器学习模型。然而，当前版本的对抗性训练方案可能会陷入某些次优解，这解释了对抗性准确性和标准准确性之间差距的增大。对抗性训练的动态非常重要，需要探索它如何以及为什么改善对抗性鲁棒性。在研究中需要关注对抗性训练的优化过程和效果。</p> <h3 id="4鲁棒性研究">4、鲁棒性研究</h3> <p>除了选择强大的攻击方法以避免过度拟合于弱攻击之外，还需要使用无梯度黑盒攻击来测试模型的真实鲁棒性，以确保梯度不仅仅是被混淆的（梯度遮蔽），从而避免给出虚假的鲁棒性感觉。对于存在对抗性扰动的原因，预计是由数据、架构和训练/学习方案等多种因素的组合导致的。对抗性训练通过修改数据和学习方案来实现鲁棒性。在研究架构时，增加模型的容量似乎有助于提高对抗性鲁棒性。未来的研究问题包括其他网络元素（如学习滤波器的大小）对鲁棒性的影响以及所有这些实体之间的相互作用是否导致或防止对抗性漏洞。为了构建和部署更安全的系统，更透明的模型可以解释和解释其功能和推理过程，从而揭示其对抗性漏洞的潜在原因。</p> <h2 id="个人感悟">个人感悟</h2> <p>1、以前对物理对抗样本的理解比较局限，这篇文章提供了很多现实中物理对抗攻击的方法和思路。根据传感器的漏洞或者运行机制进行攻击，本身也是一种强有效的攻击方法。</p> <p>2、最近想了解一下自动驾驶系统中对抗样本的相关研究，文章虽然不新，但是对我这个新手来说十分有帮助。作者也在最后分享了他认为未来关于自动驾驶鲁棒性研究的四大方向。</p>]]></content><author><name></name></author><category term="论文笔记"/><category term="AI安全"/><category term="对抗攻击"/><category term="自动驾驶"/><summary type="html"><![CDATA[探讨自动驾驶中物理对抗攻击的种类及其对系统安全性的影响，分析不同传感器面临的对抗攻击方法，并提出相应的防御策略。]]></summary></entry><entry><title type="html">雕刻字自动排样算法</title><link href="https://alanchancl.github.io/blog/2023/%E9%9B%95%E5%88%BB%E5%AD%97%E8%87%AA%E5%8A%A8%E6%8E%92%E6%A0%B7%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="雕刻字自动排样算法"/><published>2023-03-22T15:07:00+00:00</published><updated>2023-03-22T15:07:00+00:00</updated><id>https://alanchancl.github.io/blog/2023/%E9%9B%95%E5%88%BB%E5%AD%97%E8%87%AA%E5%8A%A8%E6%8E%92%E6%A0%B7%E7%AE%97%E6%B3%95</id><content type="html" xml:base="https://alanchancl.github.io/blog/2023/%E9%9B%95%E5%88%BB%E5%AD%97%E8%87%AA%E5%8A%A8%E6%8E%92%E6%A0%B7%E7%AE%97%E6%B3%95/"><![CDATA[<h2 id="1简介">1、简介</h2> <p>雕刻机自动套料软件主要用于户外广告行业，以往从业者在使用雕刻机时为达到材料最省的目的常需要进行大量人工拆分文字、图形并进行排版等的工作，耗时耗力且不够科学。因此开发一款可以实现自动拆分及套料的软件，代替以往人工操作的形式。</p> <h2 id="2改进点">2、改进点</h2> <ul> <li>实现对中文、外文、标准多边形和特殊形状的自动套料。</li> <li>针对以往的封闭图形内部的封闭图形被打散的情况进行优化。</li> <li>可对排版间距的大小进行选择和调整。</li> <li>在节省人力的同时，也保证了材料的节省。</li> </ul> <h2 id="3主要方法">3、主要方法</h2> <p>本项目的雕刻字自动排版的算法主要由两个方面的大循环组成：一是字体排版的位置循环，二是字体排版的角度循环。由于母版中存在无穷多个可能的摆放位置点，且配合上角度的360次变化，会造成字体排版的效率低下。 针对以上问题，该算法主要利用逐步求精的方法：母版的无数个位置点，利用间距相同的网格点代替；字体排版角度的1~360度的尝试，也是首先通过大角度的搜寻最佳角度范围，再通过小角度的细致确定。通过此方法，在保证字体排版的效果的情况下，提高了排版的效率。</p> <h2 id="4实验环境">4、实验环境</h2> <ul> <li>实验平台：MATLAB</li> <li>测试字体：<strong>小弦科技有限公司</strong></li> </ul> <h2 id="5结果展示">5、结果展示</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303221542547-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303221542547-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303221542547-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303221542547.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="派样效果展示图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">派样效果展示图</div> <p>整体效果排列紧密</p>]]></content><author><name></name></author><category term="技术笔记"/><category term="排样算法"/><summary type="html"><![CDATA[本文介绍了一种雕刻字自动排样算法，旨在提高雕刻机的排版效率，减少人工操作，节省材料成本。该算法能够自动处理中文、外文及各种形状的文字排版，优化封闭图形的排版效果，并允许用户自定义排版间距，适用于户外广告行业的实际需求。]]></summary></entry><entry><title type="html">能识别物体的触觉手套</title><link href="https://alanchancl.github.io/blog/2023/%E8%A7%A6%E8%A7%89%E6%89%8B%E5%A5%97%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB/" rel="alternate" type="text/html" title="能识别物体的触觉手套"/><published>2023-02-28T15:30:00+00:00</published><updated>2023-02-28T15:30:00+00:00</updated><id>https://alanchancl.github.io/blog/2023/%E8%A7%A6%E8%A7%89%E6%89%8B%E5%A5%97%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB</id><content type="html" xml:base="https://alanchancl.github.io/blog/2023/%E8%A7%A6%E8%A7%89%E6%89%8B%E5%A5%97%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB/"><![CDATA[<h2 id="1简介">1、简介</h2> <p>希望利用触觉压力弯曲手套，结合深度学习算法，实现用手套抓取物体时能自动识别被抓取的物体类别。并搭建一个可视化界面进行展示。</p> <h2 id="2触觉手套">2、触觉手套</h2> <p>触觉手套由16个压力传感器和6个弯曲传感器组成，16个压力传感器均匀分布在手掌用来捕获抓握物体时压力数据，6个弯曲传感器分布在手背捕获手指弯曲程度。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041023674-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041023674-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041023674-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041023674.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="触觉手套示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">触觉手套示意图</div> <h2 id="3触觉信号采集">3、触觉信号采集</h2> <p>采集了19样物体的触觉信号</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041026471-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041026471-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041026471-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041026471.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="触觉信号采集示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">触觉信号采集示意图</div> <h2 id="4利用pyqtgraph搭建可视化界面">4、利用pyqtgraph搭建可视化界面</h2> <p>由左侧的信号现实栏，中间的触觉数据集样本栏，右侧的预测物体和概率分布栏</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041029594-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041029594-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041029594-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041029594.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="可视化界面示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">可视化界面示意图</div> <h2 id="5深度学习训练分类模型">5、深度学习训练分类模型</h2> <p>这里简单搭建了一个CNN模型对触觉信号进行分类，效果还行可以达到80%左右。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def cnnModel():

    model = Sequential()
    model.add(Conv2D(128, (2,2), input_shape=(win_len,22,1), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2,2), padding='valid'))
    model.add(Dropout(0.3))
    model.add(Flatten())
    model.add(Dense(256, activation='relu'))
    model.add(Dense(256, activation='relu'))
    model.add(Dense(16, activation='softmax'))
    adam = optimizers.Adam(lr=0.001, decay=1e-6)
    model.compile(loss='categorical_crossentropy', optimizer=adam, metrics=['accuracy'])
    return model
</code></pre></div></div> <h2 id="6效果演示">6、效果演示</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041236107-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041236107-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041236107-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202303041236107.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="效果演示" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">效果演示</div>]]></content><author><name></name></author><category term="技术笔记"/><category term="嵌入式"/><summary type="html"><![CDATA[本文介绍了一种基于触觉手套的物体识别系统，利用深度学习算法实现对抓取物体的自动识别，旨在提升人机交互的智能化水平。]]></summary></entry><entry><title type="html">FSR402压力传感器Unity演示</title><link href="https://alanchancl.github.io/blog/2023/FSR402%E5%8E%8B%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8E%8B%E5%8A%9B-Unity%E6%BC%94%E7%A4%BA.md/" rel="alternate" type="text/html" title="FSR402压力传感器Unity演示"/><published>2023-02-05T23:58:17+00:00</published><updated>2023-02-05T23:58:17+00:00</updated><id>https://alanchancl.github.io/blog/2023/FSR402%E5%8E%8B%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8E%8B%E5%8A%9B-Unity%E6%BC%94%E7%A4%BA.md</id><content type="html" xml:base="https://alanchancl.github.io/blog/2023/FSR402%E5%8E%8B%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8E%8B%E5%8A%9B-Unity%E6%BC%94%E7%A4%BA.md/"><![CDATA[<h2 id="1-方案简介">1. 方案简介</h2> <p>通过FSR402压力传感器检测压力数据，利用Arduino读取IO口的电压信息，将压力数据通过串口传输给电脑，python读取串口数据后将压力数据传递给Unity，并制作出两只手指挤压小球的动画展示压力大小。</p> <h2 id="2fsr402压力传感器电路">2.FSR402压力传感器电路</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302131952316-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302131952316-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302131952316-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302131952316.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="FSR402接线图" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">FSR402接线图</div> <h2 id="3-ardunio接收并串口发送数据">3. Ardunio接收并串口发送数据</h2> <pre><code class="language-#C">#include &lt;Arduino.h&gt;

int fsrPin0 = A0;     // A0 接口
int fsrPin1 = A1;     // A0 接口
int fsrReading0;
int fsrReading1;

void setup(void) 
{
  Serial.begin(9600);
}

void loop(void) 
{
  fsrReading0 = analogRead(fsrPin0);
  fsrReading1 = analogRead(fsrPin1);
  Serial.print(fsrReading0);
  Serial.print(",");
  Serial.print(fsrReading1);
  Serial.print("\n");
  delay(100);
}
</code></pre> <h2 id="4-python接收数据并通过socket发送给unity">4. Python接收数据并通过Socket发送给Unity</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import serial
import socket

ser = serial.Serial('COM3', 9600, timeout=0.2)

#socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
serverAddressPort = ("127.0.0.1", 5054)#这里的IP地址无关紧要，因为Unity中会搜寻全部地址，关键是端口号一致就行

# 接收返回的信息
while True:

    while ser.inWaiting()&gt;0: 
        data = []
        revdata = ser.readline()
        revdata = str(revdata)[2:len(str(revdata))-3]
        A0,A1 = revdata.split(',')
        data.extend([int(A0), int(A1)])
        print(data)
        sock.sendto(str.encode(str(data)), serverAddressPort)
</code></pre></div></div> <h2 id="5-unity配置">5. Unity配置</h2> <p>这里包括Unity中socket数据的接收、小球和摄像头的布置、还有挤压小球时小球Mesh变化的代码</p> <h3 id="51-socket接收第四步中python传来的数据">5.1 socket接收第四步中Python传来的数据</h3> <ul> <li>Unity中新建Project</li> <li>在场景（Scene）或者GameObject中新建空对象（Create Empty），这里我把他命名为Manger，用来存放UDP接受Python数据的Script代码。</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132006302-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132006302-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132006302-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132006302.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" title="Unity中新建Manager对象" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">Unity中新建Manager对象</div> <ul> <li>将<strong>UDPReceive.cs</strong>文件拖入到Project中的Assets文件夹中</li> </ul> <pre><code class="language-#CSS">##UDPReceive.cs##

using UnityEngine;
using System;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Threading;

public class UDPReceive : MonoBehaviour
{

    Thread receiveThread;
    UdpClient client; 
    public int port = 5052;
    public bool startRecieving = true;
    public bool printToConsole = false;
    public string data;


    public void Start()
    {

        receiveThread = new Thread(
            new ThreadStart(ReceiveData));
        receiveThread.IsBackground = true;
        receiveThread.Start();
    }

    // receive thread
    private void ReceiveData()
    {

        client = new UdpClient(port);
        while (startRecieving)
        {

            try
            {
                IPEndPoint anyIP = new IPEndPoint(IPAddress.Any, 0);
                byte[] dataByte = client.Receive(ref anyIP);
                data = Encoding.UTF8.GetString(dataByte);

                if (printToConsole) { print(data); }
            }
            catch (Exception err)
            {
                print(err.ToString());
            }
        }
    }

}
</code></pre> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017452-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017452-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017452-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017452.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Unity配置界面1" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017451-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017451-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017451-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132017451.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Unity配置界面2" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">Unity配置界面</div> <h3 id="52-新建小球和左右摄像头">5.2 新建小球和左右摄像头</h3> <p>在Unity场景中新建小球：GameObject -&gt; 3DObject -&gt; Sphere *在Unity场景中左右摄像头：GameObject -&gt; Camera 并将左右Camera移动至小球的左右侧，小球处于摄像头中心位置。这里是为了让摄像头发出射线，从而模拟两只手指抓握时发力的场景。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132018867-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132018867-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132018867-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132018867.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Unity场景设置" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">Unity场景设置</div> <h3 id="53-挤压小球时mesh变化的代码">5.3 挤压小球时Mesh变化的代码</h3> <p><a href="https://blog.csdn.net/qq_39574690/article/details/124658090?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5-124658090-blog-102668009.pc_relevant_multi_platform_whitelistv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5-124658090-blog-102668009.pc_relevant_multi_platform_whitelistv1&amp;utm_relevant_index=9">参考网址</a>实现效果如下：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132020857-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132020857-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132020857-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132020857.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="小球变形效果" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">小球变形效果</div> <h3 id="54-参照53中的代码加入压力数据">5.4 参照5.3中的代码加入压力数据</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MeshChangeDemo : MonoBehaviour
{
    public UDPReceive udpReceive;
    public MeshFilter meshFilter;
    public Camera LeftCamera,RightCamera;
    public float changeForce = 10f;//10f
    public float springForce = 20f;//20f
    public float forceOffset = 0.1f;
    public float damping = 5f;
    public float uniformScale = 1f;
    public float uniformScaleRate = 0f;
    
    private Mesh mesh;
    private Vector3[] originVertices;
    private Vector3[] displayVertices;
    private Vector3[] vertexVelocities;
    // Start is called before the first frame update
    void Start()
    {
        uniformScale = transform.localScale.x;
        mesh = meshFilter.mesh;
        originVertices = (Vector3[])mesh.vertices.Clone();
        displayVertices = (Vector3[])mesh.vertices.Clone();
        vertexVelocities = new Vector3[displayVertices.Length];
    }

    // Update is called once per frame
    void Update()
    {
        RaycastHit hit;
                string data = udpReceive.data;
        
        data = data.Remove(0, 1);
        data = data.Remove(data.Length - 1, 1);
        
        string[] points = data.Split(',');
        
        float A0 = (float.Parse(points[0])+0.1f)/850;
        float A1 = (float.Parse(points[1])+0.1f)/850;
        //print(A0);
        //print(A1);

        //if (A0 &gt; 0.01)
        //{
            if (Physics.Raycast(RightCamera.ScreenPointToRay(new Vector3(180, 180, 0)), out hit))
            {
                MeshChangeDemo meshChangeDemo = hit.transform.GetComponent&lt;MeshChangeDemo&gt;();
                if (meshChangeDemo != null)
                {
                    meshChangeDemo.ChangeMesh(hit.point + hit.normal * forceOffset, changeForce* A0);
                }
            }


            for (int i = 0; i &lt; displayVertices.Length; i++)
            {
                Vector3 v = vertexVelocities[i];
                Vector3 displacement = displayVertices[i] - originVertices[i];
                v -= displacement * springForce * Time.deltaTime; //回弹形状
                v *= 1f - damping * Time.deltaTime;               //阻尼
                vertexVelocities[i] = v;
                //displayVertices[i] += v * (Time.deltaTime / uniformScale); //应用速度 除以uniformScale是为了兼容缩放了物体的情况 可理解为放大物体则形变更小，反之更大
                float uniform = (uniformScale * uniformScaleRate);
                if (uniform == 0)
                {
                    uniform = 1;
                }
                displayVertices[i] += v * (Time.deltaTime / uniform);
            }
            mesh.vertices = displayVertices;
            mesh.RecalculateNormals();
        //}

        //if (A1 &gt; 0.01)
        //{
            RaycastHit hit1;

            if (Physics.Raycast(LeftCamera.ScreenPointToRay(new Vector3(200, 165, 0)), out hit1))
            {
                MeshChangeDemo meshChangeDemo = hit1.transform.GetComponent&lt;MeshChangeDemo&gt;();
                if (meshChangeDemo != null)
                {
                    meshChangeDemo.ChangeMesh(hit1.point + hit1.normal * forceOffset, changeForce* A1);
                }
            }

            for (int i = 0; i &lt; displayVertices.Length; i++)
            {
                Vector3 v = vertexVelocities[i];
                Vector3 displacement = displayVertices[i] - originVertices[i];
                v -= displacement * springForce * Time.deltaTime; //回弹形状
                v *= 1f - damping * Time.deltaTime;               //阻尼
                vertexVelocities[i] = v;
                //displayVertices[i] += v * (Time.deltaTime / uniformScale); //应用速度 除以uniformScale是为了兼容缩放了物体的情况 可理解为放大物体则形变更小，反之更大
                float uniform = (uniformScale * uniformScaleRate);
                if (uniform == 0)
                {
                    uniform = 1;
                }
                displayVertices[i] += v * (Time.deltaTime / uniform);
            }
            mesh.vertices = displayVertices;
            mesh.RecalculateNormals();
        //}
    }

    public void ChangeMesh(Vector3 point, float force)
    {
        point = transform.InverseTransformPoint(point);
        for (int i = 0; i &lt; displayVertices.Length; i++)
        {
            Vector3 pointToVertex = displayVertices[i] - point;
            //注意：物体缩放了，但是这里获取到的物体网格顶点实际是没有缩放时的顶点位置，也就是会是得到的一个错误的向量 如果你的物体被缩放了。
            pointToVertex *= uniformScale;//处理物体被缩放，但是模型本身顶点没缩放 导致向量与实际不符，现在乘上一个缩放系数它自身 如果是2倍则是会将向量还原到正确的倍数            
            float f = force / (1f + pointToVertex.sqrMagnitude); //Fv = F / (1 + d^2) 获取顶点受力公式
            float v = f * Time.deltaTime;                        //dv = a * dt  a = F/m 设m=1，则 dv = F * dt
            vertexVelocities[i] += pointToVertex.normalized * v;
        }
    }

}
</code></pre></div></div> <h2 id="6-效果展示">6. 效果展示</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030807-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030807-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030807-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030807.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="FSR402+Arduino采集数据" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">FSR402+Arduino采集数据</div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029445-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029445-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029445-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029445.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Python串口读取数据" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029255-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029255-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029255-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132029255.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Unity接收数据" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">左：Python串口读取数据 | 右：Unity接收数据</div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030791-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030791-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030791-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302132030791.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Unity挤压小球动画展示" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">Unity挤压小球动画展示</div>]]></content><author><name></name></author><category term="技术笔记"/><category term="嵌入式"/><summary type="html"><![CDATA[使用FSR402压力传感器采集压力数据并通过Unity进行可视化演示]]></summary></entry><entry><title type="html">PyTorch Geometric(PyG) 库的安装</title><link href="https://alanchancl.github.io/blog/2023/PyTorch-Geometric(PyG)-%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/" rel="alternate" type="text/html" title="PyTorch Geometric(PyG) 库的安装"/><published>2023-02-01T14:20:17+00:00</published><updated>2023-02-01T14:20:17+00:00</updated><id>https://alanchancl.github.io/blog/2023/PyTorch%20Geometric(PyG)%20%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85</id><content type="html" xml:base="https://alanchancl.github.io/blog/2023/PyTorch-Geometric(PyG)-%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"><![CDATA[<p>PyG库简介PyG的全称是 PyTorch Geometric,是一款基于 PyTorch 的几何深度学习框架,可以简单方便的实现图神经网络。以下为安装过程。</p> <p>以下是我的Requirements.txt：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Python == 3.8
cuda == 10.2
Pytorch == 1.5.1
torch-geometric==1.5.0
</code></pre></div></div> <h2 id="1创建新的conda环境">1.创建新的conda环境</h2> <p>新建一个名字为PyG的python版本为3.8的新环境，记住这里安装的python版本，后续选择包的时候需要。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create -n PyG python=3.8 -y
activate PyG
</code></pre></div></div> <h2 id="2安装pytorch和cuda">2.安装Pytorch和CUDA</h2> <p>选择Pytorch的版本和对应版本的cuda，具体安装指令可以参考<a href="https://pytorch.org/get-started/previous-versions/">官网</a>。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda install pytorch==1.5.1 torchvision==0.6.1 cudatoolkit=10.2 -c pytorch -y
</code></pre></div></div> <h2 id="3安装pyg库">3.安装PyG库</h2> <p>需要的安装包（需要安装以下顺序安装）：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>torch_scatter
torch_sparse
torch_cluster
torch_spline_conv
torch-geometric
</code></pre></div></div> <p>下载网址：<a href="https://data.pyg.org/whl/">https://data.pyg.org/whl/</a></p> <p>选择torch和cuda的版本：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011720951-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011720951-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011720951-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011720951.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" title="PyG安装包版本选择" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">PyG安装包版本选择</div> <p>进入后下载<strong>torch_scatter 、torch_sparse 、torch_cluster 、torch_spline_conv</strong>四个包：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011722505-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011722505-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011722505-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202302011722505.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" title="PyG依赖包下载" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">PyG依赖包下载</div> <p>python版本是3.8的选cp38，还要判断是win还是linux。</p> <p>下载后将四个包放置在同一个文件夹。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cd</span> <span class="n">D</span><span class="p">:</span>\<span class="n">XXX</span>\<span class="n">XX</span>\  <span class="c1"># 安装包所存的位置
</span><span class="n">pip</span> <span class="n">install</span> <span class="n">torch_scatter</span><span class="o">-</span><span class="mf">2.0</span><span class="p">.</span><span class="mi">5</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">win_amd64</span><span class="p">.</span><span class="n">whl</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">torch_sparse</span><span class="o">-</span><span class="mf">0.6</span><span class="p">.</span><span class="mi">7</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">win_amd64</span><span class="p">.</span><span class="n">whl</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">torch_cluster</span><span class="o">-</span><span class="mf">1.5</span><span class="p">.</span><span class="mi">7</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">win_amd64</span><span class="p">.</span><span class="n">whl</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">torch_spline_conv</span><span class="o">-</span><span class="mf">1.2</span><span class="p">.</span><span class="mi">0</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">cp38</span><span class="o">-</span><span class="n">win_amd64</span><span class="p">.</span><span class="n">whl</span>
</code></pre></div></div> <p>最后选择好版本PyG版本直接安装即可。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install torch-geometric==1.5.0
</code></pre></div></div> <h3 id="4-测试">4. 测试</h3> <p>最后，在安装完毕后可以用下面的这段代码进行测试一下。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">import</span> <span class="n">torch.nn.functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="n">torch_geometric.nn</span> <span class="kn">import</span> <span class="n">MessagePassing</span>
<span class="kn">from</span> <span class="n">torch_geometric.utils</span> <span class="kn">import</span> <span class="n">softmax</span><span class="p">,</span> <span class="n">add_remaining_self_loops</span>


<span class="k">class</span> <span class="nc">GATConv</span><span class="p">(</span><span class="n">MessagePassing</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">in_feats</span><span class="p">,</span> <span class="n">out_feats</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">drop_prob</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">(</span><span class="n">aggr</span><span class="o">=</span><span class="sh">"</span><span class="s">add</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">drop_prob</span> <span class="o">=</span> <span class="n">drop_prob</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lin</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">in_feats</span><span class="p">,</span> <span class="n">out_feats</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">out_feats</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">leakrelu</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">nn</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="nf">xavier_uniform_</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">):</span>
        <span class="n">edge_index</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">add_remaining_self_loops</span><span class="p">(</span><span class="n">edge_index</span><span class="p">)</span>
        <span class="c1"># 计算 Wh
</span>        <span class="n">h</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">lin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 启动消息传播
</span>        <span class="n">h_prime</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">propagate</span><span class="p">(</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">h</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h_prime</span>

    <span class="k">def</span> <span class="nf">message</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x_i</span><span class="p">,</span> <span class="n">x_j</span><span class="p">,</span> <span class="n">edge_index_i</span><span class="p">):</span>
        <span class="c1"># 计算a(Wh_i || wh_j)
</span>        <span class="n">e</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">((</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">x_i</span><span class="p">,</span> <span class="n">x_j</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">self</span><span class="p">.</span><span class="n">a</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">leakrelu</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="nf">softmax</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">edge_index_i</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">dropout</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">drop_prob</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">training</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_j</span> <span class="o">*</span> <span class="n">alpha</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">conv</span> <span class="o">=</span> <span class="nc">GATConv</span><span class="p">(</span><span class="n">in_feats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">out_feats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span>
        <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nf">conv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="技术笔记"/><category term="PyG"/><summary type="html"><![CDATA[PyTorch Geometric(PyG)库的安装教程，包括环境配置、CUDA安装和依赖包安装的详细步骤]]></summary></entry><entry><title type="html">Obsidian | Templater插件+QuickAdd插件自动模板</title><link href="https://alanchancl.github.io/blog/2022/Obsidian-Templater%E6%8F%92%E4%BB%B6+QuickAdd%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%A8%A1%E6%9D%BF/" rel="alternate" type="text/html" title="Obsidian | Templater插件+QuickAdd插件自动模板"/><published>2022-09-02T14:20:17+00:00</published><updated>2022-09-02T14:20:17+00:00</updated><id>https://alanchancl.github.io/blog/2022/Obsidian-Templater%E6%8F%92%E4%BB%B6+QuickAdd%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%A8%A1%E6%9D%BF</id><content type="html" xml:base="https://alanchancl.github.io/blog/2022/Obsidian-Templater%E6%8F%92%E4%BB%B6+QuickAdd%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%A8%A1%E6%9D%BF/"><![CDATA[<p>Obsidian黑曜石是一个功能强大的知识管理软件，是一款功能强大的带有关系图谱功能的双向链笔记，它可基于纯文本Markdown文件的本地文件夹上运行。</p> <ul> <li>Templater插件可以在不同文件夹中调用不同模板，生成新的文件。适合生成工作日报、论文笔记这些格式固定的文档。</li> <li>QuickAdd插件可以让Templater插件创建新文档时，以规定的形式对文档进行命名。例如：以日期命名的日记文档。</li> </ul> <h2 id="1-插件安装">1. 插件安装</h2> <ul> <li> <ol> <li>【设置】，第三方插件。</li> </ol> </li> <li> <ol> <li>社区插件市场，【浏览】。</li> </ol> </li> <li> <ol> <li>搜索Templater和QuickAdd并安装，需要科学上网才能搜索到。</li> </ol> </li> <li> <ol> <li>开启两个插件开关</li> </ol> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329866-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329866-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329866-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329866.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Obsidian插件安装界面" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">Obsidian插件安装界面</div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052346390-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052346390-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052346390-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052346390.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="已安装的插件列表" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">已安装的插件列表</div> <h2 id="2创建模板">2.创建模板</h2> <p>创建所需要的模板，这个模板将会在每次创建新文档时被反复调用。以下以工作日报模板为例子。</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="s">创建时间：2023-02-06 08:42</span>
<span class="s">Tags：日报</span>
<span class="nn">---</span>
<span class="gh"># 一、今日工作</span>

<span class="gu">## 关键事项</span>

<span class="gu">## 临时工作</span>

<span class="gh"># 二、问题与收获</span>

<span class="gu">## 问题</span>

<span class="gu">## 收获</span>

<span class="gh"># 三、明日计划</span>
</code></pre></div></div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329525-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329525-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329525-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329525.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="工作日报模板示例" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">工作日报模板示例</div> <h2 id="3-插件设置">3. 插件设置</h2> <h3 id="templater插件设置">Templater插件设置</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329468-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329468-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329468-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052329468.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Templater插件设置界面" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">Templater插件设置界面</div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330896-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330896-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330896-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330896.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Templater模板文件夹设置" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">Templater模板文件夹设置</div> <p>设置好之后，每次你在指定的文件夹里面【新建笔记】时，都会自动以模板生成名字为【未命名】的新文件。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330638-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330638-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330638-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330638.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="使用模板创建新文件" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">使用模板创建新文件</div> <h3 id="quickadd插件配置">QuickAdd插件配置</h3> <p>如果不需要在新建笔记时，模板文件自动命名的话。其实就不需要配置QuickAdd这个插件了。QuickAdd插件中的template功能可以自动生成模板并以固定日期格式命名。比较适合写日记或者工作日报周报。</p> <p>进入QuickAdd插件的设置页面，进行以下设置。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330353-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330353-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330353-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330353.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="QuickAdd插件设置界面" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">QuickAdd插件设置界面</div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330515-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330515-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330515-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330515.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="QuickAdd模板设置" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">QuickAdd模板设置</div> <p>完成之后，你就可以在主页面按【ctrl+P】进入控制面板，查找【创建日报】，并选择。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330960-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330960-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330960-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052330960.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="使用QuickAdd创建日报" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">使用QuickAdd创建日报</div> <p>你就会发现在指定文件夹中生成了，以日期为名字的模板文件。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052331367-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052331367-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052331367-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/202302052331367.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="自动生成的日报文件" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">自动生成的日报文件</div> <h2 id="参考资料">参考资料</h2> <p><a href="https://sspai.com/post/72385">每日笔记、日程管理、工作复盘——这是我钻研出的 Obsidian 八般武艺 - 少数派 (sspai.com)</a></p>]]></content><author><name></name></author><category term="技术笔记"/><category term="Obsidian"/><summary type="html"><![CDATA[Obsidian Templater插件和QuickAdd插件的安装与使用教程，包括模板创建和自动命名功能]]></summary></entry><entry><title type="html">蛤蟆先生去看心理医生</title><link href="https://alanchancl.github.io/blog/2022/%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F%E5%8E%BB%E7%9C%8B%E5%BF%83%E7%90%86%E5%8C%BB%E7%94%9F/" rel="alternate" type="text/html" title="蛤蟆先生去看心理医生"/><published>2022-06-16T17:50:17+00:00</published><updated>2022-06-16T17:50:17+00:00</updated><id>https://alanchancl.github.io/blog/2022/%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F%E5%8E%BB%E7%9C%8B%E5%BF%83%E7%90%86%E5%8C%BB%E7%94%9F</id><content type="html" xml:base="https://alanchancl.github.io/blog/2022/%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F%E5%8E%BB%E7%9C%8B%E5%BF%83%E7%90%86%E5%8C%BB%E7%94%9F/"><![CDATA[<ul> <li> <p>罗伯特·戴博德</p> </li> <li> <p>天津人民出版社</p> </li> </ul> <hr/> <p>【<strong>儿童自我状态（Child Ego State）</strong>：指一个人的存在模式：行为和感受，都像一个孩子。儿童自我状态是由我们童年残留的遗迹搭建而成，包含我们小时候体验过的所有情感。刚出生时，便具备自然型儿童中的五种最基本的情感。幼年时，这些基本情感逐渐发展演变成更微妙、更复杂的行为模式，这些行为模式成为自我的核心，融为我们自身的一部分，定义了我们的一生。正因为这样，某些特定大的情形和场景会激发我们的基本行为模式，让我们自动做出反应，所以我们会和小时候一样去行动和感受。】</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210569-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210569-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210569-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210569.jpg" class="img-fluid rounded z-depth-1" width="50%" height="auto" title="儿童自我状态示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">儿童自我状态示意图</div> <p>【自然型儿童：快乐和深情”“愤怒”“悲伤”“恐惧”这五种基本情感与生俱来，相当于情绪的红黄蓝三原色。 适应型儿童：婴幼儿虽然不能用逻辑或者有意识地去应对和防御父母观念和行为所带来的影响，但他们会从经验中学习。这样的学习不仅涉及头脑思考，也涉及全部的自我。我们学到的是一种生存的策略，并发展出一套行为来应对父母和其他人。这意味着每一个婴儿都必须学习如何调整他的基本行为，来应对自己所处的初始状况。这些调整，就像原子核一样，以后我们所有的行为都围绕着这个核心形成和发展。】</p> <p>作者在这抛出了儿童自我状态的概念，人们进入儿童状态后，他们的感受和行为都和小时候的自己如出一辙，与实际年龄并没有关系。每个刚出生的婴孩都具有自然型儿童的天生情感，随着孩子的身体强壮，能量充沛，情感世界也会丰富起来，但在这个过程中也有其他因素参与进来，其中最重要的就是父母，他们从一开始就对这个孩子的意识产生影响。婴儿做的几乎所有事情都会引发母亲或父亲的某些反应，这些反应对孩子具有深远的影响。</p> <hr/> <p>【就像是画家调色板上的红黄蓝三原色一样，每一个“自然型儿童”都具备基本情感。但随着我们必须学习调整自然行为来适应特殊情形。我们会将三原色的色调调暗，使它们看上去柔和，以利于生存，同时也借此保护我们个体的完整性。这就意味着我们得学会处理愤怒，包括父母的愤怒，还有我们自己的。 <strong>顺从行为</strong>：是正在发展情感和情绪的孩子处理与父母之间九个的一种适应性行为。”如果你被迫顺从某个人，就意味着你不与他争辩。你照他们说的去做，而且同意他们的想法“ ”我想，真正让人惊讶的是我们成年后有多少行为是从童年学来的。你只要想一想，就会发现这其实非常明显。童年体验到的最强烈的情绪，不可避免地变成我们成年后经常有的感受。有诗人曾说‘孩子是成年人的父亲’，或许就是这个意思。“ ”对大多数人而言，成长的本质就是要减少并最终打破这样的依赖关系，这样才能成为一个独立自主的人。很少有人能完全达成这点，有些人能部分达成，而很多人则会依赖一辈子。顺从行为可能会导致有些人永远没有真正长大为人“】</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210160-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210160-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210160-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250210160.jpg" class="img-fluid rounded z-depth-1" width="50%" height="auto" title="顺从行为示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">顺从行为示意图</div> <p>顺从行为的概念让我想到了我小时候根据我爸妈两人带我的性格不同，所自然发展出来的两种截然不同的相处模式。小时候爸爸的严父形象一直让我在他面前规规矩矩，相反在慈母妈妈面前我会更愿意表达自己的意见和情感。所以成绩好时我会拿试卷给我爸签名，成绩不好是我就会拿给妈妈签名。</p> <hr/> <p>【<strong>撒泼</strong>正是表达愤怒的一种幼稚的方式，就像孩子听到大人说‘不行，你不能这样！’这让孩子非常愤怒，同时又感到无助，因为对那个让他生气的大人，孩子无法用暴力或者带有攻击性的行为去回应，所以唯一能做的就是躺倒在地，又踢又叫。 不带攻击性地释放愤怒需要一段时间。其中在‘适应性儿童’的所有行为里，<strong>怄气</strong>是最能说明怎样用时间来稀释愤怒的例子。怄气可以持续很久，几个小时甚至好几天。怄气的人总是绷着脸、阴沉沉的样子，而且安静地很反常。通常这是孩子在权威之下无法随性所欲才做出的反应。成年人或许会因为输掉一场权力斗争而生闷气，也是同样的道理。说白了，怄气是输家在对强大的赢家做出反应。 我们每一个人都必须适应各自童年的特定情形，所以就产生了各种行为模式，关联着各种情感和情绪，像马赛克的色彩一样繁多复杂。因此很多人的许多行为都源自于“适应性儿童”的自己。】</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250211335-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250211335-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250211335-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250211335.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="怄气示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">怄气示意图</div> <p>【这个图的关键在于，所有这些行为策略实际上都从我们童年发展而来的防御机制，用来保护我们免受到危害。这危害可能是真是存在的，也可能是想象出来的。当成年人怄气、撒泼、郁闷或是厌烦的时候，我们会想他们究竟是行为不当，还是在无意识或无法控制地重演童年的行为模式】</p> <p>怄气确实是我小时候对抗奶奶和爸爸一些要求的行为，现在想来确实觉得幼稚，但是作为儿童对抗权威和表达愤怒的一种方式也无可厚非。因此也应该给接受其存在。</p> <hr/> <p>【<strong>父母自我状态（Parent Ego State）：</strong>当处于‘父母自我状态’时，我们表现得正如自己的父母。记住，他们是我们最早接触的人，因此对我们的影响是不可估量的。‘父母状态’包含了自从出生，我们从父母那里学到的所有价值观和道德观，还包括了对生活的评判标准，让我们借此判断是非对错。这些价值来自父母，所以父母是最能左右我们行为的人。他们的言行塑造了我们童年的生活，也不可避免地对我们之后的人生产生影响。】</p> <p>每个人都会从父母的行为方式中进行学习，因此每个人都有父母自我状态。</p> <p>【<strong>成人自我状态（Adult Ego State）：</strong>成人状态下，我们能计划、考虑、决定、行动，我们能理性而合理地行事。处于这个状态时，我们所有的指示和技能都能为自己所用，而不再被脑子里父母过去的声音所驱使，也不会被童年的情绪所围困。相反，我们能思考当下的状况，基于事实来决定要做什么。】</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250212738-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250212738-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250212738-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250212738.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="成人自我状态示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">成人自我状态示意图</div> <p>【<strong>只有在成人自我状态里，才能学到关于自我的新知识。</strong>在‘儿童自我状态’时，你会体验到童年的感受，好的坏的都有。你会再现过去的情形，再次体验过去的情绪，可你学不到任何新的东西。当处在‘父母自我状态’时，基本上你不是在挑剔就是在教育别人。不管是哪种，你都在用言行重复从父母那里学来的观念和价值观，你会想证明给别人看，让别人接受你的观念和价值观。这种确信无疑的状态，就没法给新知识和新理念留出一席之地。旧的思想主宰着你，这就是为什么单靠争论不能改变一个人的想法，只会让人更固执己见。只有处在‘成人自我状态’时，你才能思考当下的事情，评估自己的行为，或者倾听别人对你的看法而不马上驳斥，当然这一点很难做到。】</p> <p>从某种意义上来说，只有当一个人处于成人自我状态时，才能在心智上成为成年人，为自己负责，为自己的行为负责。就会认识到你对自己是有自主权的。因此你就知道自己有力量来改变处境，更重要的是，有力量改变自己。</p> <hr/> <p>【每个人的早年经历本质上是不同的，所以每个人看到的都是一个不同的世界。有时候，人们看到的世界如此不同，连信念和预设都不尽相同，最严重的时候，这些人在之后的人生里只能经过留学冲突才能达成和解。每一个生命一定都得经历开始、中间和结束这三个阶段，而开始的阶段会显著地影响后来的阶段。因此你对世界的看法实在人生的最初阶段里形成的。】</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250213109-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250213109-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250213109-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250213109.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="人生坐标示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">人生坐标示意图</div> <p>【<strong>人生坐标：</strong>一旦我们在童年决定用哪种态度和观点，变成我们存在的底层架构。从那之后，我们便建构出一个世界，不断确认和支持这些信念和预期。换一个词来说，我们把自己的人生变成了一个<strong>‘自证预言’</strong>。 <strong>自证预言：</strong>我们会控制事件的发生，从而确保预言会成真。我们会确保自己的世界和预期一样。】</p> <p>‘自证预言’上次舍友和我聊天的时候也聊起了相同的概念，叫做‘自我预言的实现’。在研二实习的时候，面对部门里面的众多学历出众和经验丰富的同事，我总是觉得自己不会出众和不能胜任一些比较有挑战性的工作（这就是我的自我预言）。因此每当组长给我委派一些比较有挑战性的工作时，我都会比较抗拒当主要的负责人，觉得应该让其他有能力的同事来带领我做。因此我也就永远无法出众和胜任有挑战性的工作，因此我的实际行为使得我之前的预言实现了。</p>]]></content><author><name></name></author><category term="读书笔记"/><category term="心理学"/><summary type="html"><![CDATA[本文探讨了儿童自我状态的概念，分析了其对个体行为和情感的深远影响，旨在帮助读者理解童年经历如何塑造成年后的自我认知与情感反应。]]></summary></entry><entry><title type="html">行人检测中的3D物理对抗样本生成方法</title><link href="https://alanchancl.github.io/blog/2022/%E8%A1%8C%E4%BA%BA%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%843D%E7%89%A9%E7%90%86%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="行人检测中的3D物理对抗样本生成方法"/><published>2022-05-01T11:30:17+00:00</published><updated>2022-05-01T11:30:17+00:00</updated><id>https://alanchancl.github.io/blog/2022/%E8%A1%8C%E4%BA%BA%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%843D%E7%89%A9%E7%90%86%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95</id><content type="html" xml:base="https://alanchancl.github.io/blog/2022/%E8%A1%8C%E4%BA%BA%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%843D%E7%89%A9%E7%90%86%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/"><![CDATA[<blockquote> <ul> <li>论文名称：<a href="http://link.zhihu.com/?target=https%3A//arxiv.org/abs/2203.03373">Adversarial Texture for Fooling Person Detectors in the Physical World</a></li> <li>作者单位：Zhanhao Hu / 清华大学</li> <li>收录时间：2022 CVPR</li> <li>文章亮点：提出了TC-EGA物理对抗样本生成方法，生成可以在多角度进行攻击的3D对抗纹理。并将生成的对抗纹理制作成衣服，成功欺骗行人检测模型。</li> </ul> </blockquote> <h2 id="motivation">Motivation</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250053199.bmp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250053199.bmp" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="对抗纹理的多角度示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">对抗纹理的多角度示意图</div> <ul> <li>现有的用于行人检测攻击的2D对抗性纹理，只有在纹理正对摄像机的时候，攻击才有效。面对不同角度的拍摄时，攻击的纹理存在一定缺失，攻击效果也会被影响。（如上图中a和b子图所示）</li> <li>将对抗纹理进行平铺可以一定程度缓解，但是不能完全解决对抗纹理在多角度下的攻击效果弱的问题。（如上图中c子图所示）</li> <li>直接对人体建立3D模型生成3D对抗性纹理，但是由于人体并不是理想刚体，3D的纹理附着在人体时还会出现一定程度的形变。这种方法复杂且效果不好。</li> </ul> <h2 id="methods">Methods</h2> <h3 id="目标函数">目标函数</h3> <p>假设对抗纹理$\widetilde{\tau}$服从$p_{adv}$分布，分布可用能量函数$U\left(\widetilde{\tau}\right)$表示： \(p_{adv}\left(\widetilde{\tau}\right)=\frac{e^{-U\left(\widetilde{\tau}\right)}}{\int_{\widetilde{\tau}}{e^{-U\left(\widetilde{\tau}\right)}\mathrm{d} \widetilde{\tau}}}\) \(z\sim\mathcal{N}\left(0,I\right)\)</p> <p>由于$\int_{\widetilde{\tau}}{e^{-U\left(\widetilde{\tau}\right)}\mathrm{d}\widetilde{\tau}}$的存在很难对$p_{adv}$分布进行计算，因此利用参数化的生成器$G_\varphi:\ z\rightarrow\widetilde{\tau}$去近似$p_{adv}$，通过控制参数生成不同的对抗纹理$\widetilde{\tau}$。其中z服从分布，将$q_\varphi\left(\widetilde{\tau}\right)$定义为对抗纹理$\widetilde{\tau}=G_\varphi\left(z\right)$的分布函数。$N$为样本的总数量。</p> <h4 id="theorem-1">Theorem 1:</h4> <table> <tbody> <tr> <td>最小化$\mathrm{KL}\left(q_\varphi\left(\widetilde{\tau}\right)</td> <td>p_{adv}\left(\widetilde{\tau}\right)\right)$等价于$\min <em>{\varphi, \omega} \mathrm{E}</em>{\tilde{\tau} \sim \mathrm{q}<em>{\varphi}(\tilde{\tau})}[\mathrm{U}(\tilde{\tau})]-\mathrm{I}</em>{\varphi, \omega}^{\mathrm{JSD}}(\tilde{\tau}, \mathrm{z})$ 其中\(I_{\varphi,\omega}^{\mathrm{JSD}}\left(\widetilde{\tau},z\right)=E_{\left(\widetilde{\tau},z\right)\sim q_\varphi^{\widetilde{\tau},\ z}}\left(\widetilde{\tau},z\right)\left[-sp\left(-T_\omega\left(\widetilde{\tau},z\right)\right)\right]-E_{\widetilde{\tau}\sim q_\varphi\left(\widetilde{\tau}\right),z^\prime\sim p_z\left(z^\prime\right)}\left[sp\left(T_\omega\left(\widetilde{\tau},z^\prime\right)\right)\right]\) $q_\varphi^{\widetilde{\tau},\ z}$为$\widetilde{\tau}$和$z$的联合分布，$sp\left(t\right)=\log{\left(1+e^t\right)}$，$T_\omega$通过神经网络表示的标量函数，需要$\widetilde{\tau}$和$z$进行优化。其中$\mathrm{E}<em>{\tilde{\mathrm{\tau}} \sim \mathrm{q}</em>{\varphi}(\tilde{\mathrm{\tau}})}[\mathrm{U}(\tilde{\mathrm{\tau}})]$被称为对抗目标函数，通过最小化$E\left[U\left(\widetilde{\tau}\right)\right]$生成有效的对抗纹理。$-I_{\varphi,\omega}^{\mathrm{JSD}}\left(\widetilde{\tau},z\right)$称为信息目标函数，通过最小化使得和之间的交互信息最大化。</td> </tr> </tbody> </table> <ol> <li> <p>对抗目标函数$\mathrm{E}<em>{\tilde{\mathrm{\tau}} \sim \mathrm{q}</em>{\varphi}(\tilde{\mathrm{\tau}})}[\mathrm{U}(\tilde{\mathrm{\tau}})]$</p> <p>对抗目标函数即为能量函数的$U(·)$的期望值，<strong>这里的关键是找到一个合适能量函数去评估对抗纹理的效果，当对抗纹理攻击效果越好，能量函数的能量越低，说明目标检测模型的识别率越低。</strong></p> <p>$E\left[U\left(\widetilde{\tau}\right)\right]$可以通过多次采样 $z$生成 $\widetilde{\tau}$ 进行计算：</p> \[E_{\widetilde{\tau}\sim q_\varphi\left(\widetilde{\tau}\right)}\left[U\left(\widetilde{\tau}\right)\right]=\frac{1}{N}\sum_{i=1}^{N}\left[U\left(G_\varphi\left(z_i\right)\right)\right]\] <p>首先，引入了<strong>目标检测中预测框的置信度</strong>作为能量函数的一部分,并表述为$U_{obj}$。同时生成的对抗纹理会经过随机尺度、对比度、亮度和附加噪声等操作和随机角度旋转两种操作。我们将这两个组合操作定义为$M\left(x,\widetilde{\tau}\right)$。因此这一部分的能量函数可以表述为：$U_{\mathrm{obj}}=E_{x,M}\left[f\left(M\left(x,\widetilde{\tau}\right)\right)\right]$，其中$f$为目标检测模型输出的置信度。</p> <table> <tbody> <tr> <td>其次再引入<strong>对抗纹理的差值</strong>总和作为能量函数的另外一部分，表述为$U_{TV}$ 。 $U_{TV}$的值越小，说明生成的对抗纹理越平滑。$U_{\mathrm{TV}}=\sum_{i,j}\left</td> <td>\tau_{i,j}-\tau_{i+1,j}\right</td> <td>+\left</td> <td>\tau_{i,j}-\tau_{i,j+1}\right</td> <td>$因此能量函数为：\(U\left(\widetilde{\tau}\right)=\frac{1}{\beta}\left(U_{\mathrm{obj}}+\alpha U_{\mathrm{TV}}\right)\)</td> </tr> </tbody> </table> </li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105286-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105286-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105286-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105286.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="对抗目标函数的计算方法示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">对抗目标函数的计算方法示意图</div> <ol> <li>信息目标函数$-I_{\varphi,\omega}^{\mathrm{JSD}}\left(\widetilde{\tau},z\right)$</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105800-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105800-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105800-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250105800.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="信息目标函数的计算方法示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">信息目标函数的计算方法示意图</div> <h3 id="基于环形裁切的可拓展生成攻击">基于环形裁切的可拓展生成攻击</h3> <p>基于环形裁切的可拓展生成攻击（Toroidal-Cropping-based Expandable Generative Attack，TC-EGA）。TC-EGA是将对抗纹理从2D拓展成3D的方法。其中主要分为两步，第一步是训练一个全卷积神经网络从对抗纹理中采样分布，第二步时搜寻最有效的对抗纹理。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106847-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106847-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106847-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106847.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="FCN来生成对抗贴图示意图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">FCN来生成对抗贴图示意图</div> <h4 id="训练对抗纹理的生成器">训练对抗纹理的生成器</h4> <p>利用FCN来生成对抗贴图，其中FCN中的padding均为0。</p> <p>这样保证了生成的对抗纹理中的每一子块都存在对抗扰动性。同时由于FCN的卷积平移不变性，对抗纹理中的每一个小的对抗子图均共享相同的模型架构和参数。因此只需要训练一个小的生成器。</p> <h4 id="生成有效的对抗纹理">生成有效的对抗纹理</h4> <p>由于生成器可以控制变量生成不同的对抗纹理，由于纹理没有特定的形状，且需要足够大的输入才能生成很大的对抗纹理，因此直接生成足够大的对抗纹理十分困难。</p> <p>因此作者采用了生成小的对抗纹理，再利用平铺生成足够大的对抗纹理的方法。</p> <p>​&lt;div class="row mt-3"&gt; &lt;div class="col-sm mt-3 mt-md-0" style="text-align: center;"&gt;</p> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106380-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106380-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106380-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106380.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="平铺生成对抗贴图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;/div&gt;
</code></pre></div></div> <p>&lt;/div&gt;</p> <div class="caption">平铺生成对抗贴图</div> <h2 id="个人感悟">个人感悟</h2> <ul> <li>生成对抗纹理的目标函数十分值得借鉴。考虑到现实的物理攻击中摄像机参数这一不可忽视的因素，要让摄像机成功捕捉到对抗纹理并进行有效的攻击，这要求人为设计的对抗纹理不能模式不能过于复杂，具体的攻击纹理不能过于细微。本文作者提出目标函数所进行的限制确实能让生成的对抗纹理更加平滑简单。</li> <li>同时利用平铺的方法将对抗纹理进行重复堆叠，解决了多角度下某些关键特征丢失的问题。</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106653-480.webp 480w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106653-800.webp 800w,https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106653-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://raw.githubusercontent.com/alanchancl/BlogImg/main/img202211250106653.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="不同的对抗贴图对比图" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption">不同的对抗贴图对比图</div>]]></content><author><name></name></author><category term="论文笔记"/><category term="AI安全"/><category term="对抗攻击"/><summary type="html"><![CDATA[本文介绍了一种新颖的3D物理对抗样本生成方法，旨在通过生成可在多角度进行攻击的对抗纹理，提升行人检测模型的攻击效果。该方法利用TC-EGA技术，将对抗纹理制作成衣物，成功欺骗行人检测系统，展示了在实际环境中对抗攻击的潜力和应用前景。]]></summary></entry><entry><title type="html">秋园</title><link href="https://alanchancl.github.io/blog/2022/%E7%A7%8B%E5%9B%AD/" rel="alternate" type="text/html" title="秋园"/><published>2022-04-29T17:50:17+00:00</published><updated>2022-04-29T17:50:17+00:00</updated><id>https://alanchancl.github.io/blog/2022/%E7%A7%8B%E5%9B%AD</id><content type="html" xml:base="https://alanchancl.github.io/blog/2022/%E7%A7%8B%E5%9B%AD/"><![CDATA[<blockquote> <ul> <li>杨本芬</li> <li>北京联合出版公司</li> </ul> </blockquote> <hr/> <blockquote> <p>我意识到：如果没人记下一些事情，妈妈在这个世界上的痕迹将迅速被抹去。在不算遥远的那一天，我自己在这个世界上的痕迹也将被抹去，就像一层薄薄的灰层被岁月吹散。我真的来过这个世界嘛？经历过的那些艰辛困苦什么都不算吗？</p> </blockquote> <hr/> <blockquote> <p>战事发展非人力所能控制，微弱的个人就像一段浮木，在时代的滔天大浪里载沉载浮，不知会被浪头打往哪一个驳岸。</p> </blockquote> <hr/> <blockquote> <p>之骅的头慢慢低了下去，喉咙里似乎堵了东西，眼睛里有了雾水，此刻，她才觉得自己好可怜。</p> </blockquote> <hr/> <blockquote> <p>阅读小说时，我一次又一次地被拉进一个家庭残缺不全的历史中，那是一个普通中国人家在时代大浪中载沉载浮、挣扎求生的过程。我惊讶地发现，这个家是靠一位裹过脚的母亲和她不幸而早慧的女儿撑持起来的。</p> </blockquote> <hr/> <blockquote> <p>我想起福克纳的小说《我弥留之际》里，艾迪的父亲常说的一句话：”活着的理由，就是为了过那种不死不活的漫长日子做准备。“ 我见过非洲大草原上牛羚横渡马拉河的场景。对牛羚来说，他们的命运就是度过马拉河，喝水会让它们一再跌倒，只要意志力稍微退却，可能连求生的意念都会放弃。 外婆、妈妈这些被放逐到社会底层的人们，在命运面前显得如此渺小无力，仿佛随时会被揉碎。然而，人比自己想象的更加柔韧，她们永远不会被彻底毁掉。当之骅——我的妈妈——在晚年拿起笔回首自己的一生，真正的救赎方才开始。</p> </blockquote> <p>昨晚看《但是还有书籍》第二季时被杨本芬老师六十多岁时，于不足四平米的厨房中，用自己的处女作《秋园》纪念母亲一生。今天就在图书馆找到后边一口气将其读完，摘录了上述印象深刻的句子。</p>]]></content><author><name></name></author><category term="读书笔记"/><category term="中国文学（小说）"/><summary type="html"><![CDATA[本文探讨了杨本芬的作品《秋园》，通过对家庭历史的回顾，展现了普通人在时代洪流中的挣扎与坚韧，尤其是母亲与女儿之间深厚的情感纽带。]]></summary></entry><entry><title type="html">硅谷钢铁侠：埃隆·马斯克的冒险人生</title><link href="https://alanchancl.github.io/blog/2022/%E7%A1%85%E8%B0%B7%E9%92%A2%E9%93%81%E4%BE%A0-%E5%9F%83%E9%9A%86-%E9%A9%AC%E6%96%AF%E5%85%8B%E7%9A%84%E5%86%92%E9%99%A9%E4%BA%BA%E7%94%9F/" rel="alternate" type="text/html" title="硅谷钢铁侠：埃隆·马斯克的冒险人生"/><published>2022-04-27T17:50:17+00:00</published><updated>2022-04-27T17:50:17+00:00</updated><id>https://alanchancl.github.io/blog/2022/%E7%A1%85%E8%B0%B7%E9%92%A2%E9%93%81%E4%BE%A0%EF%BC%9A%E5%9F%83%E9%9A%86%C2%B7%E9%A9%AC%E6%96%AF%E5%85%8B%E7%9A%84%E5%86%92%E9%99%A9%E4%BA%BA%E7%94%9F</id><content type="html" xml:base="https://alanchancl.github.io/blog/2022/%E7%A1%85%E8%B0%B7%E9%92%A2%E9%93%81%E4%BE%A0-%E5%9F%83%E9%9A%86-%E9%A9%AC%E6%96%AF%E5%85%8B%E7%9A%84%E5%86%92%E9%99%A9%E4%BA%BA%E7%94%9F/"><![CDATA[<blockquote> <ul> <li>阿什利·万斯（周恒星·译）</li> <li>中信出版社</li> </ul> </blockquote> <hr/> <p>【“你决定做特斯拉的时候，电动车还没今天这么火，哪些因素让你判断这是个机会？” “我从来没觉得电动车是个‘好机会’。我其实一直觉得做特斯拉的失败率比成功率大得多，”他顿了下说， “我只是觉得这是应该要去做的事情，而且我不想苦等别人来实现。”】</p> <p>马斯克知道如何创造财富，但是也更加关注自己创造财富的目的。当极客公园创始人张鹏问马斯克关于当时炒得很热的“亚轨道旅行”的看法，他表示除了赚富豪的钱，对技术和人类没有任何实质的推进作用的项目，他毫无兴趣并且嗤之以鼻。</p> <p>“创造财富，改变世界”这个现代企业家精神在马斯克身上得到了很好的体现。财富不是他的人生目标，而是一个更高目标的实现路径。</p> <hr/> <p>【埃隆·马斯克就是这样的一个企业家。他17岁一个人离开南非的家去加拿大寻找新生活，21岁拿到宾夕法尼亚大学的奖学金到美国读书，28岁时以3亿美元卖掉了他创办的第一家互联网公司，31岁时以15亿美元卖掉了他和彼得·蒂尔联合创办的第二家互联网公司。 然后，他拿着自己全部的财产投身实业，<strong>自杀般地同时从事航空航天、电动汽车和太阳能这三个发展长期停滞不前的高科技行业。</strong>最艰苦的时候，面临其中两家企业同时倒闭的危险，也被庸众当作兜售虚假希望的骗子。最后，他忍受着难以想象的屈辱和压力，奇迹般地把这三家企业都做成了：SpaceX成为航空航天业最稳定的运营商，特斯拉已经是全球最酷最畅销的纯电动豪华汽车，太阳城目前是最大的消费者商用太阳能电池板安装供应商。 完成了这些看似绝无可能的任务之后，他不暇停留，又野心勃勃地开始了尝试让人类能够移民火星的未来10年计划。】</p> <p>上述这段话是对马斯克目前人生和成就的最好的总结，如果下次需要对其他人简单介绍马斯克，我会引用上面的表述。</p> <hr/> <p>【马斯克的经历给中国企业家的启发：首先，他有宏大的视野。很多企业家更关心赚钱多少，而马斯克关心的是人类的命运。就像美国哲学家爱默生所说的，<strong>一个一心向着目标前进的人，全世界都会给他让路。一个宏大的目标，会给你更多的社会支持，也让你获得更大的容错度。</strong>其次，他有破釜沉舟的勇气。他常常引用丘吉尔的名言：“既然必须穿越地狱，那就走下去吧。”这种勇气往往会让人绝地逢生。最后，他有着自己独到的<strong>“第一原理”</strong>思维方式。也就是说，<strong>凡事先从本质开始思考，然后再从本质一层层往回反推。</strong>在这样的思维模式下，你不会因为暂时的困难而对结果失去信心，也不会因为好高骛远而做出徒劳的努力——因为你非常清楚自己的目标是“第一原理”推导出的必然结果。】</p> <p>不仅仅关注获利多少，而且把民族、国家和人类命运作为更远大的目标的企业家。社会给予其更大的包容度与社会支持。我们在生活中总是倾向于比较别人已经做过了或者正在做的这件事情，我们就也去做。这样的结果是只能产生细小的迭代发展。第一性原理的思考方式是用物理学的角度看待世界的方法，也就是说一层层剥开事物的表象，看到里面的本质，然后再从本质一层层往上走。走向你要的目的。</p> <hr/> <p>【以布罗根为例，通常由经理为员工设置完成期限，而马斯克则引导他的工程师们自己掌控交付日期。“他不会说，你必须在周五下午2点前完成这项任务。他会说，‘我需要这项艰巨的任务在周五下午2点前完成，你能做到吗？’”布罗根说道，“然后，如果你说了‘能做到’，<strong>那么你勤奋工作的原因就不再是因为他的要求，而是为了你自己。</strong>这是一个你可以感受到的区别。你为自己的工作写下了保证书。”】</p> <p>毫无疑问，在充分发挥员工价值方面，马斯克是当之无愧的大师。</p>]]></content><author><name></name></author><category term="读书笔记"/><category term="人物传记"/><summary type="html"><![CDATA[本文探讨了埃隆·马斯克的创业历程与成就，分析了他在电动汽车、航空航天和可再生能源等领域的创新与影响力，旨在激励更多企业家关注人类未来的发展。]]></summary></entry></feed>